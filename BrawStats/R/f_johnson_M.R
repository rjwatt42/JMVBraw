f_johnson_M <- function(mu,sd,skew,kurt){
  # - use moments to estimate parameters of a Johnson distribution
  #
  # USAGE: result = f_johnson_M(mu,sd,skew,kurt)
  #
  # mu   = mean
  # sd   = standard deviation
  # skew = skewness
  # kurt = kurtosis
  #
  # result = structure of results with the following fields:
  #  .coef = parameters as: coef = [gamma delta xi lambda];
  #  .type = type of Johnson distribution as: SL, SU, SB, SN, or ST
  #
  # SEE ALSO: f_johnson_fit, f_johnson_Q
  
  # -----Notes:-----
  # This function implements Hill et al.'s (1976) algorithm for estimating the
  # parameters of a Johnson curve using moments. It is based on their original
  # FORTRAN souce code (AS-99), which was obtained from
  # http://lib.stat.cmu.edu/apstat/99. For SN (Normal) curves they arbitrarily set
  # lambda to 0, but the present function sets lambda = 1. This produces the
  # correct identity transform needed by their companion algorithm (AS-100) and
  # the 'f_johnson_y2z' & 'f_johnson_z2y' functions in this toolbox. The C code
  # mentioned in Simonato (2011) does this as well, but is not mentioned in the
  # documentation.
  #
  # The coefficients of a Johnson curve consist of shape (gamma & delta),
  # location (xi), and scale (lambda) parameters and use the following transforms:
  #  SL: Lognormal distribution = exponential transform
  #  SU: Unbounded distribution = hyperbolic sine transform
  #  SB: Bounded distribution   = logistic transforma
  #
  # Hill et al.'s (1976) algorithm adds support for two additional families as:
  #  SN: Normal distribution = identity transform
  #  ST: SB curves on the B2 = B1+1 boundary (T refers to "two-ordinate")
  #
  # SL curves are bounded on one end (e.g., Gamma distribution), while SB curves
  # are bounded on both ends (e.g., Beta distribution). SU curves are unbounded
  # (e.g., the Normal and t distributions).
  #
  # Note that the SN and ST families were added to the Johnson system by Hill et
  # al. (1976), the former being the normal distribution. The parameters returned
  # by fitting an ST curve are not used to transform the normal curve like they
  # are in the other families. For ST curves, xi and lambda represent the
  # ordinates on the skewness-kurtosis plane, delta is the proportion of values at
  # lambda, and gamma is set to 0.
  
  # -----References:-----
  # Hill, I. D. 1976. Algorithm AS 100: Normal-Johnson and Johnson-Normal
  #  Transformations. Journal of the Royal Statistical Society. Series C (Applied
  #  Statistics) 25(2): 190-192.
  # Hill, I. D., R. Hill, and R. L. Holder, 1976. Algorithm AS 99: Fitting Johnson
  #  curves by moments. Journal of the Royal Statistical Society. Series C
  #  (Applied Statistics) 25(2): 180-189.
  # Johnson, N. L. 1949. Systems of frequency curves generated by methods of
  #  translation. Biometrika 36: 149-176.
  # Simonato, J. G. 2011. The performance of Johnson distributions for value at
  #  risk and expected shortfall computation. Journal of Derivatives 19:7-24.
  
  # -----Author:-----
  # by David L. Jones, Mar-2014
  #
  # This file is part of the 'JOHNSON CURVE TOOLBOX FOR MATLAB'
  # and is released under the BSD 2-clause license.
  
  # -----Set defaults & check input:-----
  
  # Check for negative SD:
  if (sd<0) { print('Cannot have a negative SD!') }
  # -------------------------------------
  
  # Call subfunction ported from Hill et al.'s (1976) FORTRAN code:
  if (abs(skew)>1) skew<-1*sign(skew)
  consts <- sub_jnsn(mu,sd,skew,kurt)
  gamma<-consts$gamma
  delta<-consts$delta
  lambda<-consts$lambda
  xi<-consts$xi
  itype<-consts$itype
  ifault<-consts$ifault

  if (itype==1 && lambda<0) { delta=-delta }
  while ((ifault==3) || (itype==1 && lambda==-1) || is.complex(gamma)){
    if (abs(skew)>0.1) {skew <- skew-sign(skew)*skew*0.25}
    else {kurt <- kurt-sign(kurt)*kurt*0.25}
    consts <- sub_jnsn(mu,sd,skew,kurt)
    gamma<-consts$gamma
    delta<-consts$delta
    lambda<-consts$lambda
    xi<-consts$xi
    itype<-consts$itype
    ifault<-consts$ifault
  }
  
  coef <- c(gamma,delta,xi,lambda)
  
  # Recode Johnson curve types:
  switch(itype,
         {type <- 'SL'},
         {type <- 'SU'},
         {type <- 'SB'},
         {type <- 'SN'},
         {type <- 'ST'}
  )
  
  # Record fault state:
  switch(ifault+1,
         msg <- "",# normal completion
         msg <- 'Negative SD',
         msg <- '(b2 < b1+two)'
  )
  
  # Wrap results up into a structure:
  return(list(coef=coef,type=type,msg=msg))
}



################################################################################
#                               SUBFUNCTION:                                   #
################################################################################
sub_jnsn <- function(xbar,sd,rb1,bb2){
  # - finds type and parameters of a Johnson curve with given first four moments
  
  # Define constants:
  tol <- 0.01
  zero <- 0.0
  quart <- 0.25
  half <- 0.5
  one <- 1.0
  two <- 2.0
  three <- 3.0
  four  <- 4.0
  
  # Check for negative SD:
  if (sd < zero) {
    itype  <- NA
    gamma <- NA 
    delta <- NA
    xlam <- NA
    xi <- NA
    ifault <- 1
    return(list(gamma=gamma,delta=delta,lambda=xlam,xi=xi,itype=itype,ifault=ifault))
  } else {
    ifault <- 0
    xi     <- zero
    xlam   <- zero
    gamma  <- zero
    delta  <- zero
  }
  
  if (sd > zero){
    b1    <- rb1*rb1
    b2    <- bb2
    fault <- 0
    # Test whether Lognormal (or Normal) requested:
    if (b2 >= zero){
      # Test for position relative to boundary line:
      if (b2 > b1+tol+one){
        if ((abs(rb1) <= tol) && (abs(b2-three) <= tol)){
          # SN (Normal) distribution:
          itype <- 4
          delta <- 1/sd
          gamma <- -xbar/sd
          xlam  <- 1# after Simonato (2011)
          return(list(gamma=gamma,delta=delta,lambda=xlam,xi=xi,itype=itype,ifault=ifault))
        } else {
          stopWhile <- 0# proceed to WHILE loop
          skip      <- 1# skip first line of WHILE loop:
        }
      } else {
        if (b2 >= b1+one) {
          # ST distribution:
          itype <- 5
          y     <- 0.5 + 0.5*sqrt(1-4/(rb1+4))
          if (rb1 > 0) y <- 1 - y
          x     <- sd/sqrt(y*(1-y))
          xi    <- xbar - y*x
          xlam  <- xi + x
          delta <- y
          return(list(gamma=gamma,delta=delta,lambda=xlam,xi=xi,itype=itype,ifault=ifault))
        }
        itype  <- 5# no 'itype' was included here in original FORTRAN
        ifault <- 2
        return(list(gamma=gamma,delta=delta,lambda=xlam,xi=xi,itype=itype,ifault=ifault))
      }
    } else {
      stopWhile <- 0# proceed to WHILE loop
      skip <- 0# don't skip 1st line of WHILE loop
    }
  } else {
    itype <- 5
    xi    <- xbar
    return(list(gamma=gamma,delta=delta,lambda=xlam,xi=xi,itype=itype,ifault=ifault))
  }
  
  while ((stopWhile==0)){
    # -----Skip this block on 1st run:-----
    if (skip==1){
      skip <- 0# don't skip anymore
    } else {
      if (!(abs(rb1) > tol)){
        itype <- 4
        delta <- 1/sd
        gamma <- -xbar/sd
        xlam  <- 1# after Simonato (2011)
        return(list(gamma=gamma,delta=delta,lambda=xlam,xi=xi,itype=itype,ifault=ifault))
      }
    }
    # -------------------------------------
    # Test for position relative to Lognormal line:
    x <- half*b1 + one
    y <- abs(rb1)*sqrt(quart*b1+one)
    u <- (x+y)^(one/three)
    w <- u + one/u - one
    u <- w*w*(three+w*(two+w)) - three
    if ((b2 < zero) || (fault)) {b2 <- u}
    x <- u - b2
    if (abs(x) <= tol){
      # Lognormal (SL) distribution:
      itype <- 1
      xlam  <- sub_sign(one,rb1)
      u     <- xlam*xbar
      x     <- one/sqrt(log(w))
      delta <- x
      y     <- half*x*log(w*(w-one)/(sd*sd))
      gamma <- y
      xi    <- xlam*(u-exp((half/x-y)/x))
      return(list(gamma=gamma,delta=delta,lambda=xlam,xi=xi,itype=itype,ifault=ifault))
      # SB or SU distribution:
    }
    if (x > zero){
      itype <- 3
      consts <- sub_sbfit(xbar,sd,rb1,b2)
      gamma<-consts$gamma
      delta<-consts$delta
      xlam<-consts$xlam
      xi<-consts$xi
      fault<-consts$fault
      
      if (fault==0)
      return(list(gamma=gamma,delta=delta,lambda=xlam,xi=xi,itype=itype,ifault=ifault))
      # Failure - try to fit approximate result:
      ifault <- 3
      if (b2 <= b1+two){
        # ST distribution:
        itype <- 5
        y     <- 0.5 + 0.5*sqrt(1-4/(rb1+4))
        if (rb1 > 0) y <- 1 - y
        x     <- sd/sqrt(y*(1-y))
        xi    <- xbar - y*x
        xlam  <- xi + x
        delta <- y
        return(list(gamma=gamma,delta=delta,lambda=xlam,xi=xi,itype=itype,ifault=ifault))
      } else {
        skip <- 0# don't skip 1st line of WHILE loop
      }
    } else {
      itype <- 2
      consts <- sub_sufit(xbar,sd,rb1,b2)
      gamma<-consts$gamma
      delta<-consts$delta
      xlam<-consts$xlam
      xi<-consts$xi
      stopWhile <- 1
    }
  }
  return(list(gamma=gamma,delta=delta,lambda=xlam,xi=xi,itype=itype,ifault=ifault))
} 



################################################################################
#                               SUBFUNCTION:                                   #
################################################################################
sub_sign <- function(A,B){
  # - port of SIGN statement from FORTRAN
  #
  # If B\ge 0 then the result is ABS(A), else it is -ABS(A).
  A      <- abs(A)
  A[(B<0)] <- -A[(B<0)]
  return(A)
}



################################################################################
#                               SUBFUNCTION:                                   #
################################################################################
sub_sufit <- function(xbar,sd,rb1,b2){
  # - finds parameters of Johnson SU curve with given first four moments
  
  # Define constants:
  tol <- 0.01; zero <- 0.0; one <- 1.0; two <- 2.0; three <- 3.0; four <- 4.0; six <- 6.0
  seven <- 7.0; eight <- 8.0; nine <- 9.0; ten <- 10.0; sixten <- 16.0; half <- 0.5
  one5 <- 1.5; two8 <- 2.8; b1 <- rb1 * rb1; b3 <- b2 - three
  
  # w is first estimate of exp(delta^(-2)):
  w <- sqrt(two*b2-two8*b1-two)
  w <- sqrt(w-one)
  
  # Initialize:
  stopWhile <- 0
  
  if (abs(rb1)>tol){
    while ((stopWhile==0)){# Johnson iteration:
      w1  <- w + one
      wm1 <- w - one
      z   <- w1*b3
      v   <- w*(six+w*(three+w))
      a   <- eight*(wm1*(three+w*(seven+v))-z)
      b   <- sixten*(wm1*(six+v)-b3)
      y   <- (sqrt(a*a-two*b*(wm1*(three+w*(nine+w*(ten+v)))-two*w1*z))-a)/b
      z   <- y*wm1*(four*(w+two)*y+three*w1*w1)^2/(two*(two*y+w1)^3)
      v   <- w*w
      w   <- sqrt(one-two*(one5-b2+(b1*(b2-one5-v*(one+half*v)))/z))
      w   <- sqrt(w-one)
      if (abs(b1-z) <= tol){
        y <- y/w
        y <- log(sqrt(y)+sqrt(y+one))
        if (rb1 > zero) y <- -y
        break# terminate WHILE loop
      } else {
        # continue next iteration of WHILE loop
      }
    }
  } else {
    # Symmetrical case - results are known
    y <- zero
  }
  x     <- sqrt(one/log(w))
  delta <- x
  gamma <- y*x
  y     <- exp(y)
  z     <- y*y
  x     <- sd/sqrt(half*(w-one)*(half*w*(z+one/z)+one))
  xlam  <- x
  xi    <- (half*sqrt(w)*(y-one/y))*x + xbar
  
  return(list(gamma=gamma,delta=delta,xlam=xlam,xi=xi))
}



################################################################################
#                               SUBFUNCTION:                                   #
################################################################################
sub_sbfit <- function(xbar,sigma,rtb1,b2){
  # - finds parameters of Johnson SB curve with given first four moments
  
  # Preallocate:
  deriv <- rep(NA,4) 
  dd <- rep(NA,4)
  
  # Define constants:
  tt <- 1.0e-4; tol <- 0.01; limit <- 50; zero <- 0.0; one <- 1.0; two <- 2.0
  three <- 3.0; four <- 4.0; six <- 6.0; half <- 0.5; quart <- 0.25; one5 <- 1.5
  a1 <- 0.0124; a2 <- 0.0623; a3 <- 0.4043; a4 <- 0.408; a5 <- 0.479; a6 <- 0.485
  a7 <- 0.5291; a8 <- 0.5955; a9 <- 0.626; a10 <- 0.64; a11 <- 0.7077; a12 <- 0.7466
  a13 <- 0.8; a14 <- 0.9281; a15 <- 1.0614; a16 <- 1.25; a17 <- 1.7973; a18 <- 1.8
  a19 <- 2.163; a20 <- 2.5; a21 <- 8.5245; a22 <- 11.346; rb1 <- abs(rtb1)
  b1 <- rb1 * rb1; neg <- (rtb1 < zero)
  
  # Get d as first estimate of delta:
  e <- b1 + one
  x <- half*b1 + one
  y <- abs(rb1)*sqrt(quart*b1+one)
  u <- (x+y)^(one/three)
  w <- u + one/u - one
  f <- w*w*(three+w*(two+w)) - three
  e <- (b2-e)/(f-e)
  if (abs(rb1)>tol){
    d <- one/sqrt(log(w))
    if (d < a10){
      f <- a16*d
    } else {
      f <- two - a21/(d*(d*(d-a19)+a22))
    }
  } else {
    f <- two
  }
  f <- e*f + one
  if (f < a18){
    d <- a13*(f-one)
  } else {
    d <- (a9*f-a4)*(three-f)^(-a5)
  }
  
  # Get g as first estimate of gamma:
  g <- zero
  if (b1 >= tt){
    if (d > one){
      if (d <= a20){
        u <- a2
        y <- a3
      } else {
        u <- a1
        y <- a7
      }
      g <- b1^(u*d+y)*(a14+d*(a15*d-a11))
    } else {
      g <- (a12*d^a17+a8)*b1^a6
    }
  }
  
  # -----Main iteration starts here:-----
  stopWhile <- 0# initialize
  m    <- 0
  while ((stopWhile==0)){
    m     <- m + 1
    fault <- (m > limit)
    if (fault) {
      gamma <- 0
      delta <- 0
      xlam  <- 0
      xi    <- 0
      return(list(gamma=gamma,delta=delta,xlam=xlam,xi=xi,fault=fault))
    }
    
    # Get first six moments for latest g and d values:
    consts <- sub_mom(g,d)
    hmu<-consts$hmu
    fault<-consts$fault
    if (fault) {
      gamma <- 0
      delta <- 0
      xlam  <- 0
      xi    <- 0
      return(list(gamma=gamma,delta=delta,xlam=xlam,xi=xi,fault=fault))
    }
    
    s     <- hmu[(1)]*hmu[(1)]
    h2    <- hmu[(2)] - s
    fault <- (h2 <= zero)
    if (fault) {
      gamma <- 0
      delta <- 0
      xlam  <- 0
      xi    <- 0
      return(list(gamma=gamma,delta=delta,xlam=xlam,xi=xi,fault=fault))
    }
    
    t    <- sqrt(h2)
    h2a  <- t*h2
    h2b  <- h2*h2
    h3   <- hmu[(3)] - hmu[(1)]*(three*hmu[(2)]-two*s)
    rbet <- h3/h2a
    h4   <- hmu[(4)] - hmu[(1)]*(four*hmu[(3)]-hmu[(1)]*(six*hmu[(2)]-three*s))
    bet2 <- h4/h2b
    w    <- g*d
    u    <- d*d
    
    # Get derivatives:
    for (j in 1:2){
      for (k in 1:4){
        t <- k
        if (j==1){
          s <- hmu[(k+1)] - hmu[(k)]
        } else {
          s <- ((w-t)*(hmu[(k)]-hmu[(k+1)])+(t+one)*(hmu[(k+1)]-hmu[(k+2)]))/u
        }
        dd[(k)] <- t*s/d
      }
      t          <- two*hmu[(1)]*dd[(1)]
      s          <- hmu[(1)]*dd[(2)]
      y          <- dd[(2)] - t
      deriv[(j)]   <- (dd[(3)]-three*(s+hmu[(2)]*dd[(1)]-t*hmu[(1)])-one5*h3*y/h2)/h2a
      deriv[(j+2)] <- (dd[(4)]-four*(dd[(3)]*hmu[(1)]+dd[(1)]*hmu[(3)])+six*(hmu[(2)]*t+
                                                                   hmu[(1)]*(s-t*hmu[(1)]))-two*h4*y/h2)/h2b
    }
    t <- one/(deriv[(1)]*deriv[(4)]-deriv[(2)]*deriv[(3)])
    u <- (deriv[(4)]*(rbet-rb1)-deriv[(2)]*(bet2-b2))*t
    y <- (deriv[(1)]*(bet2-b2)-deriv[(3)]*(rbet-rb1))*t
    
    # Form new estimates of g and d:
    g <- g - u
    if ((b1 == zero) || (g < zero)) g <- zero
    d <- d - y
    
    # Assess WHILE loop:
    if ((abs(u) <= tt) && (abs(y) <= tt)){
      delta <- d
      xlam  <- sigma/sqrt(h2)
      if (neg){
        gamma  <- -g
        hmu[(1)] <- one - hmu[(1)]
      } else {
        gamma  <- g
      }
      xi <- xbar - xlam*hmu[(1)]
      break# terminate WHILE loop
    }
  }
  return(list(gamma=gamma,delta=delta,xlam=xlam,xi=xi,fault=fault))
}


################################################################################
#                               SUBFUNCTION:                                   #
################################################################################
sub_mom <- function(g,d){
  # - evaluates 1st six moments of a johnson SB distribution, using Goodwin method
  
  # -----Notes:-----
  # rttwo : sqrt(2.0)
  # rrtpi : reciprocal of sqrt(pi)
  # expa  : a value such that exp(expa) does not quite cause overflow
  # expb  : a value such that 1.0 + exp(-expb) may be taken to be 1.0
  
  # Define constants:
  zz <- 1.0e-5; vv <- 1.0e-8; limit <- 500; rttwo <- 1.414213562; rrtpi <- 0.5641895835
  expa <- 80.0; expb <- 23.7; zero <- 0.0; quart <- 0.25; half <- 0.5; p75 <- 0.75
  one <- 1.0; two <- 2.0; three <- 3.0; w <- g/d
  
  # Preallocate or initialize:
  a     <- rep(NA,6)
  b     <- rep(NA,6)
  fault <- 0
  c     <- rep(0,6)
  
  # Trial value of h:
  if (w > expa) {
    fault <- 1
    return(list(hmu=a,fault=fault))
  }
  
  e <- exp(w) + one
  r <- rttwo/d
  h <- p75
  if (d < three) h <- quart*d
  k <- 1
  
  # -----OUTER WHILE loop:-----
  skip     <- 1# skip 1st block of outer WHILE loop on 1st run
  stop_out <- 0# initiialize
  while ((stop_out==0)){
    # -----Skip this block on 1st run:-----
    if (skip==1){
      skip <- 0# don't skip anymore:
    } else {
      k <- k + 1
      if ( k > limit ) {
        fault <- 1
        return(list(hmu=a,fault=fault))
      }
      for (i in 1:6){
        c[(i)] <- a[(i)]
      }
      #  No convergence yet - try smaller h:
      h <- half*h
    }
    # -------------------------------------
    t <- w
    u <- t
    y <- h*h
    x <- two*y
    a[1] <- one/e
    for (i in 2:6){
      a[i] <- a[i-1]/e
    }
    v <- y
    f <- r*h
    m <- 0
    # -----INNER WHILE loop evaluates infinite series:-----
    stop_inn <- 0
    break_out <- 0
    while ((stop_inn==0)){
      m <- m + 1
      if (m > limit) break # terminate INNER WHILE loop
      for (i in 1:6){
        b[i] <- a[i]
      }
      u <- u - f
      z <- one
      if (u > -expb) z <- exp(u) + z
      t <- t + f
      l <- (t > expb)
      if (l==0) s <- exp(t) + one
      p <- exp(-v)
      q <- p
      for (i in 1:6){
        aa <- a[i]
        p  <- p/z
        ab <- aa
        aa <- aa + p
        if (aa == ab) break # terminate this FOR loop
        if (l==0){
          q  <- q/s
          ab <- aa
          aa <- aa + q
          l <- (aa==ab)
        }
        a[(i)] <- aa
      }
      y <- y + x
      v <- v + y
      for (i in 1:6){
        if (a[(i)]==zero) {
          fault <- 1
          return(list(hmu=a,fault=fault))
        }
        if (abs((a[i]-b[(i)])/a[(i)]) > vv){
          cont_inn <- 1# continue next iteration of INNER WHILE loop
          break# terminate this FOR loop
        } else {
          cont_inn <- 0# don't continue
        }
      }
      if (cont_inn!=1) {
        v <- rrtpi*h
        for (i in 1:6){
          a[(i)] <- v*a[(i)]
        }
        for (i in 1:6){
          if (a[(i)] == zero)  {
            fault <- 1
            return(list(hmu=a,fault=fault))
          }
          if (abs((a[(i)]-c[(i)])/a[(i)]) > zz){
            break_out <- 1# signal OUTER WHILE loop should be terminated
            break# terminate this FOR loop
          } else {
            break_out <- 0# don't terminate OUTER WHILE loop
          }
        }
        if (break_out==1) break# terminate INNER WHILE loop
      }
    }
    # -----------------------------------------------------
    if (break_out==1) break# terminate OUTER WHILE loop
  }
  return(list(hmu=a,fault=fault))
  # ---------------------------
}